#!/usr/bin/env python
#
# Copyright (C) 2004, 2005, 2006, 2007, 2008 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Simple and `quite' generic LCG generator."""

import os
import sys, getopt, os, lcg

OPTIONS = (
    ('encoding=', 'utf-8', "Input encoding (output encoding is always utf-8)"),
    ('stylesheet=', 'default.css', "Filename of the stylesheet to use."),
    ('inline-styles', False, "Embed styles into the HTML pages."),
    ('ext=', 'txt', "Extension of the source files."),
    ('root=', 'index', "Filename of the root document."),
    ('lang=', None, "Language variant to generate (all variants are generated by default)."),
    ('translations=', None, "Colon separated list of translation directories."),
    ('sec-lang=', None, "Secondary content language to use for citations."),
    ('html', False, "generate static HTML files (default)."),
    ('hhp', False, "generate a MS HTML Help Workshop package."),
    ('ims', False, "generate an IMS package."),
    ('pdf', False, "generate output in PDF format."),
    )

HTML = 'html'
HHP = 'hhp'
IMS = 'ims'
PDF = 'pdf'

def main():
    # Process options.
    opt, args = getoptions(OPTIONS)
    if opt is None or len(args) not in (1, 2):
        usage(OPTIONS)
    src = args[0]
    dst = len(args) == 2 and args[1] or None
    # Find out whether the input is a single file or a directory.
    if os.path.isfile(src):
        src, filename = os.path.split(src)
        name = os.path.splitext(os.path.splitext(filename)[0])[0]
        lang = os.path.splitext(os.path.splitext(filename)[0])[1][1:] or None
        ext = os.path.splitext(filename)[1][1:]
        recourse = False
    else:
        name = opt['root']
        ext = opt['ext']
        lang = opt['lang']
        recourse = True
    # Select the output format if options make sense.
    formats = [k for k in (HTML, IMS, HHP, PDF) if opt[k]]
    if not formats:
        output_format = HTML
    elif len(formats) > 1:
        lcg.log("Select just one output format!")
        sys.exit()
    else:
        output_format = formats[0]
    if dst is None:
        if output_format == PDF:
            # PDF has always just one output file (per each language variant), so there is no harm
            # to write it to the current directory by default.  Other formats generate a file
            # structure, so we require an explicit directory name.
            dst = '.'
        elif recourse:
            die("You must specify the destination directory!")
    # Process the passed-in translation directories.
    translations = (lcg.config.translation_dir,)
    if opt['translations']:
        translations += tuple([os.path.abspath(d) for d in opt['translations'].split(':')])
    #######################################################################################
    # Read the source files (first real action after processing options).
    reader = lcg.reader(src, name, ext=ext, recourse=recourse, encoding=opt['encoding'])
    node = reader.build()
    # Decide which exporter to use.
    kwargs = {}
    if output_format == PDF:
        from lcg import pdf
        cls = pdf.PDFExporter
    elif output_format == HHP:
        from lcg import hhp
        cls = hhp.HhpExporter
    else:
        if output_format == IMS:
            from lcg import ims
            cls = ims.IMSExporter
        else:
            cls = lcg.HtmlStaticExporter
        kwargs = dict(stylesheet=opt['stylesheet'], inlinestyles=opt['inline-styles'])
    # Create the exporter instance.
    exporter = cls(translations=translations, **kwargs)
    # Write the exported content to output file(s).
    if output_format == PDF and dst.lower().endswith('.pdf'):
        # TODO: Something similar would make sense for other formats too, at least when generating
        # just one document (no recursion).
        dst, filename = os.path.split(dst)
    else:
        filename = None
    exporter.dump(node, dst, filename=filename, variant=lang, sec_lang=opt['sec-lang'])


def getoptions(optspec):
    import getopt
    try:
        optlist, args = getopt.getopt(sys.argv[1:], '', [x[0] for x in optspec])
    except getopt.GetoptError:
        return None, None
    opt = dict(optlist)
    options = {}
    for option, default, descr in optspec:
        if option.endswith('='):
            option = option[:-1]
            options[option] = opt.get('--'+option, default)
        else:
            options[option] = opt.has_key('--'+option)
    return options, args


def dumpoptions(optspec, width=80, indent=3):
    from textwrap import wrap
    options = []
    maxlen = 0
    for option, default, descr in optspec:
        if option.endswith('='):
            option += '<value>'
            descr += "  Default is %r." % default
        maxlen = max(maxlen, len(option))
        options.append((option, descr))
    spacer = ' '*(maxlen+7+indent)
    return "\n".join(["%s--%s ... " % (indent*' ', o.ljust(maxlen)) + \
                      ("\n"+spacer).join(wrap(d, width-len(spacer)))
                      for o, d in options])

def die(msg):
    sys.stderr.write(msg +"\n")
    sys.exit(2)

def usage(optspec):
    help = """Usage: %s [options] source [destination]

Options:
%s

If <source> is a directory, this directory will be recoursed and a document
hierarchy will be built from the source files found in this directory and its
subdirectories.  The options --root and --ext can be used in this case to
control which document is the root document and what extension is used to
recognize source files.

If <source> is a file, a single document is read just from this file (options
--root and --ext have no effect).

If your LCG installation is placed in a non-standard installation directory,
set LCGDIR environment variable to its location."""
    die(help % (os.path.split(sys.argv[0])[-1], dumpoptions(optspec, width=80, indent=2)))

    
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except SystemExit:
        raise
    except:
        einfo = sys.exc_info()
        try:
            import cgitb
            sys.stderr.write(cgitb.text(einfo))
        except Exception, e:
            sys.stderr.write("Unable to generate detailed traceback: "+ str(e) +"\n")
            import traceback
            traceback.print_exception(*einfo)
