#!/usr/bin/env python
#
# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Simple and `quite' generic LCG generator."""

import os
import sys, getopt, os, lcg

OPTIONS = (
    ('encoding=', 'utf-8', ("Default input file encoding (may be overriden by emacs-like "
                            "encoding header for particular source files)")),
    ('styles=', 'default.css', "Filename of the stylesheet to use (or a colon separated list)."),
    ('inline-styles', False, "Embed styles into the HTML pages."),
    ('ext=', 'txt', "Extension of the source files."),
    ('root=', 'index', "Filename of the root document."),
    ('lang=', None, "Language variant to generate (all variants are generated by default)."),
    ('translations=', None, "Colon separated list of translation directories."),
    ('sec-lang=', None, "Secondary content language to use for citations."),
    ('html', False, "generate static HTML files (default)."),
    ('hhp', False, "generate a MS HTML Help Workshop package."),
    ('ims', False, "generate an IMS package."),
    ('pdf', False, "generate output in PDF format."),
    )

HTML = 'html'
HHP = 'hhp'
IMS = 'ims'
PDF = 'pdf'

def main():
    # Process options.
    opt, args = getoptions(OPTIONS)
    if opt is None or len(args) not in (1, 2):
        usage(OPTIONS)
    src = args[0]
    dst = len(args) == 2 and args[1] or None
    # Find out whether the input is a single file or a directory.
    if os.path.isfile(src):
        src, filename = os.path.split(src)
        name = os.path.splitext(os.path.splitext(filename)[0])[0]
        lang = os.path.splitext(os.path.splitext(filename)[0])[1][1:] or None
        ext = os.path.splitext(filename)[1][1:] or None
        recourse = False
    else:
        name = opt['root']
        ext = opt['ext']
        lang = opt['lang']
        recourse = True
    # Select the output format if options make sense.
    formats = [k for k in (HTML, IMS, HHP, PDF) if opt[k]]
    if not formats:
        output_format = HTML
    elif len(formats) > 1:
        lcg.log("Select just one output format!")
        sys.exit()
    else:
        output_format = formats[0]
    if dst is None:
        if output_format == PDF:
            # PDF has always just one output file (per each language variant), so there is no harm
            # to write it to the current directory by default.  Other formats generate a file
            # structure, so we require an explicit directory name.
            dst = '.'
        elif output_format == HTML and not recourse:
            opt['inline-styles'] = True
            dst = '.'
        else:
            die("You must specify the destination directory!")
    # Process the passed-in translation directories.
    translations = (lcg.config.translation_dir,)
    if opt['translations']:
        translations += tuple([os.path.abspath(d) for d in opt['translations'].split(':')])
    #######################################################################################
    # Read the source files (first real action after processing options).
    reader = lcg.reader(src, name, ext=ext, recourse=recourse, encoding=opt['encoding'])
    node = reader.build()
    # Decide which exporter to use.
    kwargs = {}
    if output_format == PDF:
        from lcg import pdf
        cls = pdf.PDFExporter
    elif output_format == HHP:
        from lcg import hhp
        cls = hhp.HhpExporter
    else:
        if output_format == IMS:
            from lcg import ims
            cls = ims.IMSExporter
        else:
            cls = lcg.HtmlStaticExporter
        kwargs = dict(styles=opt['styles'].split(':'), inlinestyles=opt['inline-styles'])
    # Create the exporter instance.
    exporter = cls(translations=translations, **kwargs)
    # Write the exported content to output file(s).
    if output_format == PDF and dst.lower().endswith('.pdf'):
        # TODO: Something similar would make sense for other formats too, at least when generating
        # just one document (no recursion).
        dst, filename = os.path.split(dst)
    else:
        filename = None
    exporter.dump(node, dst, filename=filename, variant=lang, sec_lang=opt['sec-lang'])


def getoptions(optspec):
    import getopt
    try:
        optlist, args = getopt.getopt(sys.argv[1:], '', [x[0] for x in optspec])
    except getopt.GetoptError:
        return None, None
    opt = dict(optlist)
    options = {}
    for option, default, descr in optspec:
        if option.endswith('='):
            option = option[:-1]
            options[option] = opt.get('--'+option, default)
        else:
            options[option] = opt.has_key('--'+option)
    return options, args


def dumpoptions(optspec, width=80, indent=3):
    from textwrap import wrap
    options = []
    maxlen = 0
    for option, default, descr in optspec:
        if option.endswith('='):
            option += '<value>'
            descr += "  Default is %r." % default
        maxlen = max(maxlen, len(option))
        options.append((option, descr))
    spacer = ' '*(maxlen+7+indent)
    return "\n".join(["%s--%s ... " % (indent*' ', o.ljust(maxlen)) + \
                      ("\n"+spacer).join(wrap(d, width-len(spacer)))
                      for o, d in options])

def die(msg):
    sys.stderr.write(msg +"\n")
    sys.exit(2)

def usage(optspec):
    help = """Usage: %s [options] source [destination]

Options:
%s

If <source> is a directory, this directory will be recoursed and a document
hierarchy will be built from the source files found in this directory and its
subdirectories.  The options --root and --ext can be used in this case to
control which document is the root document and what extension is used to
recognize source files.

If <source> is a file, a single document is read just from this file (options
--root and --ext have no effect).  Inline styles are forced to true in this
case if outout format is HTML.

<destination> is the target directory.  It may be omited if output is PDF
(always has single output file) or HTML with single source document (resulting
in one output file too).  The output is placed in the current directory in
this case.  In other cases the destination directory is required to prevent
unwanted polution of the current directory by the output files.

If your LCG installation is placed in a non-standard installation directory,
set LCGDIR environment variable to its location.

"""
    die(help % (os.path.split(sys.argv[0])[-1], dumpoptions(optspec, width=80, indent=2)))

def lcg_exception_details(title, details=[], reason=None):
    """Print LCG specific details about the printed exception.

    Attributes:
      title -- a short string describing the type of information displayed
      details -- a list of detailed information (see 'ProcessingError.info()')
      reason -- reason for the error (error message)

    Multi-line texts in 'details' are delimited by markings for easier reading.
      
    """
    def format(line):
        # Format one record in information output.
        assert len(line) == 2
        if "\n" in line[1]:
            return "%s:\n---begin---\n%s\n---end---" % line
        else:
            return "%s: %s" % line
    return """\n\n%s:\n%s\n\nError: %s\n""" % \
           (title, "\n".join([format(line) for line in reversed(details)]), reason)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except SystemExit:
        raise
    except lcg.ProcessingError, p:
        # Handles errors due to wrong format of input file. Gives the reason for the error and
        # clues to find it in form of name of the defective file and some section of text in which
        # the error is located.
        sys.stderr.write(lcg_exception_details("PARSING ERROR (error in source text)",
                                               p.info(), p.reason()))
        sys.exit(1)
    except Exception, ex:
        einfo = sys.exc_info()
        try:
            import cgitb
            sys.stderr.write(cgitb.text(einfo))
        except Exception, e:
            sys.stderr.write("Unable to generate detailed traceback: "+ str(e) +"\n")
            import traceback
            traceback.print_exception(*einfo)
        # The _lcg_processing_details exception attribute should not be generally used to pass data
        # about errors in input. It is much prefered that you raise a proper ProcessingError
        # exception whenever the error can be clearly identified as an error in input. The bellow
        # exception attribute can serve 1) to better debug programming errors by giving pointers to
        # which piece of input it triggered and 2) to find errors in input which are not caught
        # right away and cause errors in program code at a different place.
        if hasattr(ex, '_lcg_processing_details'):
            sys.stderr.write(lcg_exception_details("LCG exception details",
                                                   ex._lcg_processing_details, str(ex)))
        sys.exit(1)
