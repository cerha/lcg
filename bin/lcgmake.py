#!/usr/bin/env python
#
# Copyright (C) 2004-2011 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Simple and `quite' generic LCG generator."""

import sys, getopt, os, lcg, string, imp, operator

OPTIONS = (
    ("Input options", (
            ('encoding=', 'utf-8',
             ("Default input file encoding (may be overriden by emacs-like "
              "encoding header for particular source files)")),
            ('ext=', 'txt',
             ("Extension of the source files.")),
            ('root=', 'index',
             ("Filename of the root document.")),
            ('translations=', None,
             ("Colon separated list of directories where translations are searched.")),
            ('presentation=', None, ("Presentation file.")),
            )),
    ("Output format selection", (
            ('html', False, "generate static HTML files (default)."),
            ('hhp', False, "generate a MS HTML Help Workshop package."),
            ('ims', False, "generate an IMS package."),
            ('pdf', False, "generate output in PDF format."),
            )),
    ("Output options", (
            ('lang=', None,
             ("Language variant to generate (all variants are generated by default).")),
            ('sec-lang=', None,
             ("Secondary content language to use for citations.")),
            ('force-lang-ext', False,
             ("If set, all generated files will have a language extension.  By default, "
              "the extension is only added if there is more than one output language.")),
            )),
    ("HTML output specific options", (
            ('styles=', 'default.css',
             ("Filename of the CSS style sheet to use (or a colon "
              "separated list).  The named files are searched in the "
              "resource directories.")),
            ('inline-styles', False,
             ("Embed styles into the HTML pages.")),
            )),
    )

HTML = 'html'
HHP = 'hhp'
IMS = 'ims'
PDF = 'pdf'

def main():
    # Process options.
    try:
        opt, args = getoptions(OPTIONS)
    except getopt.GetoptError:
        usage(OPTIONS)
    if len(args) not in (1, 2):
        usage(OPTIONS)
    src = args[0]
    dst = len(args) == 2 and args[1] or None
    # Find out whether the input is a single file or a directory.
    if os.path.isfile(src):
        src, filename = os.path.split(src)
        name = os.path.splitext(os.path.splitext(filename)[0])[0]
        lang = os.path.splitext(os.path.splitext(filename)[0])[1][1:] or None
        ext = os.path.splitext(filename)[1][1:] or None
        recourse = False
    else:
        name = opt['root']
        ext = opt['ext']
        lang = opt['lang']
        recourse = True
    # Select the output format if options make sense.
    formats = [k for k in (HTML, IMS, HHP, PDF) if opt[k]]
    if not formats:
        output_format = HTML
    elif len(formats) > 1:
        lcg.log("Select just one output format!")
        sys.exit()
    else:
        output_format = formats[0]
    if dst is None:
        if output_format == PDF:
            # PDF has always just one output file (per each language variant), so there is no harm
            # to write it to the current directory by default.  Other formats generate a file
            # structure, so we require an explicit directory name.
            dst = '.'
        elif output_format == HTML and not recourse:
            opt['inline-styles'] = True
            dst = '.'
        else:
            die("You must specify the destination directory!")
    # Process the passed-in translation directories.
    translations = (lcg.config.translation_dir,)
    if opt['translations']:
        translations += tuple([os.path.abspath(d) for d in opt['translations'].split(':')])
    #######################################################################################
    # Read the source files (first real action after processing options).
    reader = lcg.reader(src, name, ext=ext, recourse=recourse, encoding=opt['encoding'])
    node = reader.build()
    # Decide which exporter to use.
    kwargs = {}
    if output_format == PDF:
        from lcg import pdf
        cls = pdf.PDFExporter
    elif output_format == HHP:
        from lcg import hhp
        cls = hhp.HhpExporter
    else:
        if output_format == IMS:
            from lcg import ims
            cls = ims.IMSExporter
        else:
            cls = lcg.HtmlStaticExporter
        kwargs = dict(styles=opt['styles'].split(':'), inlinestyles=opt['inline-styles'])
    kwargs['force_lang_ext'] = opt['force-lang-ext']
    # Create the exporter instance.
    exporter = cls(translations=translations, **kwargs)
    # Write the exported content to output file(s).
    if output_format == PDF and dst.lower().endswith('.pdf'):
        # TODO: Something similar would make sense for other formats too, at least when generating
        # just one document (no recursion).
        dst, filename = os.path.split(dst)
    else:
        filename = None
    if opt['presentation'] is None:
        presentation = None
    else:
        presentation = read_presentation(opt['presentation'])
    exporter.dump(node, dst, filename=filename, variant=lang, sec_lang=opt['sec-lang'],
                  presentation=presentation)

def read_presentation(filename):
    presentation = lcg.Presentation()
    try:
        f = open(filename)
    except:
        die("Can't open file: %s" % (filename,))
    try:
        confmodule = imp.load_module('_lcg_presentation', f, filename, ('.py', 'r', imp.PY_SOURCE))
    except Exception, e:
        die("Can't process configuration: %s" % (e,))
    finally:
        f.close()
    for o in dir(confmodule):
        if o[0] in string.lowercase and hasattr(presentation, o):
            setattr(presentation, o, confmodule.__dict__[o])
    return presentation

def getoptions(optspec):
    optlist = reduce(operator.add, [optlist for section, optlist in optspec], ())
    import getopt
    opts, args = getopt.getopt(sys.argv[1:], '', [x[0] for x in optlist])
    optdict = dict(opts)
    options = {}
    for option, default, doc in optlist:
            if option.endswith('='):
                option = option[:-1]
                options[option] = optdict.get('--'+option, default)
            else:
                options[option] = optdict.has_key('--'+option)
    return options, args


def dumpoptions(optspec, width=80, indent=3):
    from textwrap import wrap
    result = []
    for section, optlist in optspec:
        maxlen = 0
        options = []
        for option, default, descr in optlist:
            if option.endswith('='):
                option += '<value>'
                descr += "  Default is %r." % default
            maxlen = max(maxlen, len(option))
            options.append((option, descr))
        spacer = ' '*(maxlen+7+indent)
        result.append(section+':')
        result.append("\n".join(["%s--%s ... " % (indent*' ', o.ljust(maxlen)) + \
                                     ("\n"+spacer).join(wrap(d, width-len(spacer)))
                                 for o, d in options]))
    return "\n\n".join(result)

def die(msg):
    sys.stderr.write(msg +"\n")
    sys.exit(2)

def usage(optspec):
    help = """Usage: %s [options] source [destination]

%s

If <source> is a directory, this directory will be processed recursively and
document hierarchy will be built from the source files found in this directory
and its subdirectories.  The options --root and --ext can be used in this case
to control which document is the root document and what extension is used to
recognize source files.

If <source> is a file, a single document is read just from this file (options
--root and --ext have no effect).  Inline styles are forced to true in this
case if outout format is HTML.

<destination> is the target directory.  It may be omited if output is PDF
(always has single output file) or HTML with single source document (resulting
in one output file too).  The output is placed in the current directory in
this case.  In other cases the destination directory is required to prevent
unwanted polution of the current directory by the output files.

If your LCG installation is placed in a non-standard installation directory,
set LCGDIR environment variable to its location.

"""
    die(help % (os.path.split(sys.argv[0])[-1], dumpoptions(optspec, width=80, indent=2)))

def lcg_exception_details(title, details=[], reason=None):
    """Print LCG specific details about the printed exception.

    Attributes:
      title -- a short string describing the type of information displayed
      details -- a list of detailed information (see 'ProcessingError.info()')
      reason -- reason for the error (error message)

    Multi-line texts in 'details' are delimited by markings for easier reading.
      
    """
    def format(line):
        # Format one record in information output.
        assert len(line) == 2
        if "\n" in line[1]:
            return "%s:\n---begin---\n%s\n---end---" % line
        else:
            return "%s: %s" % line
    return """\n\n%s:\n%s\n\nError: %s\n""" % \
           (title, "\n".join([format(line) for line in reversed(details)]), reason)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except SystemExit:
        raise
    except lcg.ProcessingError, p:
        # Handles errors due to wrong format of input file. Gives the reason for the error and
        # clues to find it in form of name of the defective file and some section of text in which
        # the error is located.
        sys.stderr.write(lcg_exception_details("PARSING ERROR (error in source text)",
                                               p.info(), p.reason()))
        sys.exit(1)
    except Exception, ex:
        einfo = sys.exc_info()
        try:
            import cgitb
            sys.stderr.write(cgitb.text(einfo))
        except Exception, e:
            sys.stderr.write("Unable to generate detailed traceback: "+ str(e) +"\n")
            import traceback
            traceback.print_exception(*einfo)
        # The _lcg_processing_details exception attribute should not be generally used to pass data
        # about errors in input. It is much prefered that you raise a proper ProcessingError
        # exception whenever the error can be clearly identified as an error in input. The bellow
        # exception attribute can serve 1) to better debug programming errors by giving pointers to
        # which piece of input it triggered and 2) to find errors in input which are not caught
        # right away and cause errors in program code at a different place.
        if hasattr(ex, '_lcg_processing_details'):
            sys.stderr.write(lcg_exception_details("LCG exception details",
                                                   ex._lcg_processing_details, str(ex)))
        sys.exit(1)
