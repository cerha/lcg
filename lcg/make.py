#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (C) 2004-2015 OUI Technology Ltd.
# Copyright (C) 2019-2025 Tomáš Cerha <t.cerha@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Simple and `quite' generic LCG generator."""

from __future__ import unicode_literals

import functools
import getopt
import lcg
import operator
import os
import re
import string
import sys

unistr = type(u'')  # Python 2/3 transition hack.


OPTIONS = (
    ("Input options", (
        ('encoding=', 'utf-8',
         ("Default input file encoding (may be overriden by emacs-like "
          "encoding header for particular source files)")),
        ('ext=', 'txt',
         ("Extension of the source files.")),
        ('root=', 'index',
         ("Filename of the root document.")),
        ('translations=', None,
         ("Colon separated list of directories where translations are "
          "searched when LCG localizes the generated documents. "
          "These directories are supposed to contain compiled GNU Gettext "
          "message catalogs in their usual structure (with subdirectories for "
          "each of the supported locales, such as 'de/LC_MESSAGES/domain.mo').")),
        ('presentation=', None, ("Presentation file.")),
    )),
    ("Output format selection", (
        ('html', False, "generate static HTML files (default)."),
        ('hhp', False, "generate a MS HTML Help Workshop package."),
        ('ims', False, "generate an IMS package."),
        ('pdf', False, "generate output in PDF format."),
        ('text', False, "generate a plain text file."),
        ('braille', False, "generate a Braille script file."),
        ('epub', False, "generate output in EPUB format."),
    )),
    ("Output options", (
        ('lang=', None,
         ("Language variant to generate (all variants are generated by default).")),
        ('sec-lang=', None,
         ("Secondary content language to use for citations.")),
        ('force-lang-ext', False,
         ("If set, all generated files will have a language extension.  By default, "
          "the extension is only added if there is more than one output language.")),
    )),
    ("HTML output specific options", (
        ('styles=', 'default.css',
         ("Filename of the CSS style sheet to use (or a colon "
          "separated list).  The named files are searched in the "
          "resource directories.")),
        ('inline-styles', False,
         ("Embed styles into the HTML pages.")),
    )),
    ("Common options", (
        ('debug', False, "run in debugging friendly mode"),
        ('plain', False, "avoid all the bells and whistles"),
    )),
)

HTML = 'html'
HHP = 'hhp'
IMS = 'ims'
PDF = 'pdf'
TEXT = 'text'
BRAILLE = 'braille'
EPUB = 'epub'

_debug = False


def main(argv, opt, args):
    global _debug
    _debug = opt['debug']
    # Select the output format if options make sense.
    formats = [k for k in (HTML, IMS, HHP, PDF, TEXT, BRAILLE, EPUB,) if opt[k]]
    if not formats:
        output_format = HTML
    elif len(formats) == 1:
        output_format = formats[0]
    else:
        die("Can't use %s together!" % ' and '.join(['--' + f for f in formats]))
    # Find out whether the input is a single file or a directory.
    if len(args) == 1:
        src, dst = args[0], None
    elif len(args) == 2:
        src, dst = args
    else:
        usage(argv)
    if os.path.isfile(src):
        src, filename = os.path.split(src)
        basename, master_ext = os.path.splitext(filename)
        name, lang_ext = os.path.splitext(basename)
        lang = lang_ext[1:] if lang_ext else opt['lang']
        ext = master_ext[1:] if master_ext else None
        recourse = False
    else:
        name = opt['root']
        ext = opt['ext']
        lang = opt['lang']
        recourse = True
    if dst is None:
        if output_format in (PDF, TEXT, BRAILLE, EPUB,):
            # PDF, plain text and Braille script have always just one output
            # file (per each language variant), so there is no harm to write it
            # to the current directory by default.  Other formats generate a
            # file structure, so we require an explicit directory name.
            dst = '.'
        elif output_format == HTML and not recourse:
            opt['inline-styles'] = True
            dst = '.'
        else:
            die("You must specify the destination directory!")
    # Initialize translation path.
    translations = [os.path.join(os.path.dirname(__file__), 'translations')]
    if opt['translations']:
        translations.extend([os.path.abspath(d) for d in opt['translations'].split(':')])
    #######################################################################################
    # Read the source files (first real action after processing options).
    kwargs = {}
    if opt['plain']:
        kwargs['cls'] = lcg.DocFileReader

    reader = lcg.reader(src, name, ext=ext, recourse=recourse, encoding=opt['encoding'], **kwargs)
    try:
        node = reader.build()
    except IOError as e:
        message = unistr(e)
        match = re.match('[[]Errno[^]]*[]] *', message)
        if match:
            message = message[match.end():]
        sys.stderr.write(message)
        sys.stderr.write('\n')
        return
    # Decide which exporter to use.
    kwargs = {}
    export_kwargs = {}
    if output_format == PDF:
        cls = lcg.PDFExporter
        export_kwargs['recursive'] = True
    elif output_format == HHP:
        cls = lcg.HhpExporter
    elif output_format == TEXT:
        cls = lcg.TextExporter
        export_kwargs['recursive'] = True
    elif output_format == BRAILLE:
        cls = lcg.BrailleExporter
        export_kwargs['recursive'] = True
    elif output_format == EPUB:
        cls = lcg.EpubExporter
    else:
        if output_format == IMS:
            cls = lcg.IMSExporter
        else:
            cls = lcg.HtmlStaticExporter
        kwargs = dict(styles=opt['styles'].split(':'), inlinestyles=opt['inline-styles'])
    kwargs['force_lang_ext'] = opt['force-lang-ext']
    # Create the exporter instance.
    exporter = cls(translations=translations, **kwargs)
    # Write the exported content to output file(s).
    if (output_format == PDF and dst.lower().endswith('.pdf') or
        output_format == TEXT and (dst.lower().endswith('.text') or
                                   dst.lower().endswith('.txt')) or
        output_format == BRAILLE and (dst.lower().endswith('.text') or
                                      dst.lower().endswith('.txt'))):
        # TODO: Something similar would make sense for other formats too, at least when generating
        # just one document (no recursion).
        dst, filename = os.path.split(dst)
    elif output_format == EPUB and dst.lower().endswith('.epub'):
        dst, filename = os.path.split(dst)
    else:
        filename = None
    presentation_option = opt['presentation']
    if presentation_option is None:
        presentation = None
    elif presentation_option[-3:] == '.py':
        presentation = read_presentation(presentation_option)
    else:
        presentation = read_style(presentation_option)
    exporter.dump(node, dst, filename=filename, variant=lang, sec_lang=opt['sec-lang'],
                  presentation=presentation, **export_kwargs)


def read_presentation(filename):
    presentation = lcg.Presentation()
    import importlib.util
    try:
        spec = importlib.util.spec_from_file_location('_lcg_presentation', filename)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
    except Exception as e:
        die("Can't process presentation file: %s" % (e,))
    for o in dir(mod):
        if o[0] in string.ascii_lowercase and hasattr(presentation, o):
            setattr(presentation, o, mod.__dict__[o])
    return lcg.PresentationSet(((presentation, lcg.TopLevelMatcher(),),))


def read_style(filename):
    style_file = lcg.StyleFile()
    try:
        f = open(filename)
    except IOError:
        die("Can't open file: %s" % (filename,))
    try:
        style_file.read(f)
    except Exception as e:
        die("Can't process style file: %s" % (e,))
    finally:
        f.close()
    return lcg.PresentationSet(style_file.presentations())


def getoptions(argv):
    optspec = functools.reduce(operator.add, [optspec for section, optspec in OPTIONS], ())
    opts, args = getopt.getopt(argv[1:], '', [x[0] for x in optspec])
    optdict = dict(opts)
    options = {}
    for option, default, doc in optspec:
        if option.endswith('='):
            option = option[:-1]
            options[option] = optdict.get('--' + option, default)
        else:
            options[option] = ('--' + option) in optdict
    return options, args


def dumpoptions(width=80, indent=3):
    from textwrap import wrap
    result = []
    for section, optspec in OPTIONS:
        maxlen = 0
        options = []
        for option, default, descr in optspec:
            if option.endswith('='):
                option += '<value>'
                descr += "  Default is %r." % default
            maxlen = max(maxlen, len(option))
            options.append((option, descr))
        spacer = ' ' * (maxlen + 7 + indent)
        result.append(section + ':')
        result.append("\n".join(["%s--%s ... " % (indent * ' ', o.ljust(maxlen)) +
                                 ("\n" + spacer).join(wrap(d, width - len(spacer)))
                                 for o, d in options]))
    return "\n\n".join(result)


def die(msg):
    sys.stderr.write(msg + "\n")
    sys.exit(2)


def usage(argv):
    help = """Usage: %s [options] source [destination]

%s

If <source> is a directory, this directory will be processed recursively and
document hierarchy will be built from the source files found in this directory
and its subdirectories.  The options --root and --ext can be used in this case
to control which document is the root document and what extension is used to
recognize source files.

If <source> is a file, a single document is read just from this file (options
--root and --ext have no effect).  Inline styles are forced to true in this
case if outout format is HTML.

<destination> is the target directory.  It may be omited if output is PDF,
plain text or Braille script (they always have single output file) or HTML with
single source document (resulting in one output file too).  The output is
placed in the current directory in this case.  In other cases the destination
directory is required to prevent unwanted polution of the current directory by
the output files.

"""
    die(help % (os.path.split(argv[0])[-1], dumpoptions(width=80, indent=2)))


def lcg_exception_details(title, details=[], reason=None):
    """Print LCG specific details about the printed exception.

    Attributes:
      title -- a short string describing the type of information displayed
      details -- a list of detailed information (see 'ProcessingError.info()')
      reason -- reason for the error (error message)

    Multi-line texts in 'details' are delimited by markings for easier reading.

    """
    def format(line):
        # Format one record in information output.
        assert len(line) == 2
        if "\n" in line[1]:
            return "%s:\n---begin---\n%s\n---end---" % line
        else:
            return "%s: %s" % line
    return """\n\n%s:\n%s\n\nError: %s\n""" % \
           (title, "\n".join([format(line) for line in reversed(details)]), reason)


def run(argv):
    try:
        opt, args = getoptions(argv)
    except getopt.GetoptError:
        usage(argv)
    try:
        main(sys.argv, opt, args)
    except KeyboardInterrupt:
        raise
    except SystemExit:
        raise
    except lcg.ProcessingError as p:
        # Handles errors due to wrong format of input file. Gives the reason for the error and
        # clues to find it in form of name of the defective file and some section of text in which
        # the error is located.
        sys.stderr.write(lcg_exception_details("PARSING ERROR (error in source text)",
                                               p.info(), p.reason()))
        sys.exit(1)
    except Exception as ex:
        if opt['plain']:
            raise
        einfo = sys.exc_info()
        try:
            import cgitb
            sys.stderr.write(cgitb.text(einfo))
        except Exception as e:
            sys.stderr.write("Unable to generate detailed traceback: " + unistr(e) + "\n")
            import traceback
            traceback.print_exception(*einfo)
        # The _lcg_processing_details exception attribute should not be generally used to pass data
        # about errors in input. It is much prefered that you raise a proper ProcessingError
        # exception whenever the error can be clearly identified as an error in input. The bellow
        # exception attribute can serve 1) to better debug programming errors by giving pointers to
        # which piece of input it triggered and 2) to find errors in input which are not caught
        # right away and cause errors in program code at a different place.
        if hasattr(ex, '_lcg_processing_details'):
            sys.stderr.write(lcg_exception_details("LCG exception details",
                                                   ex._lcg_processing_details, unistr(ex)))
        if _debug:
            import pdb
            pdb.post_mortem(sys.exc_info()[2])
        sys.exit(1)

if __name__ == "__main__":
    run(sys.argv)
